" Turn on line numbers
set number

" Indent *.feature files by 2 spaces, anything else by 4
function! SetIndentation()
    if empty(matchstr(expand('%'), '\.feature$'))
        set tabstop=4 shiftwidth=4
    else
        set tabstop=2 shiftwidth=2
    endif
endfunction
autocmd BufNewFile,BufRead * exec SetIndentation()

" Automatic indentation
set autoindent
set smartindent

" Search while typing pattern
set incsearch

" Highlight search pattern matches
set hlsearch

" Automatically format doxygen style comments
set comments=sl:/**,mb:\ *,elx:\ */

" Insert comment leader when hitting enter in insert mode
set formatoptions+=r

" Insert comment leader when hitting o in normal mode
set formatoptions+=o

" Font name for gVim
set guifont=Monaco\ 11

" Draw a margin in the 81th column
set colorcolumn=81

" Show current line and column numbers
set ruler

" Command line is 2 lines, so it's easier to type complex commands
set cmdheight=2

" Hide everything from GUI
set guioptions=''

" Highlight syntax
syntax on

" Some nice colorscheme
colorscheme evening
if has('gui_running')
    colorscheme koehler
endif

" Make constants readable on projector as well
highlight Constant ctermbg=black ctermfg=green

" Always show status line
set laststatus=2

" Statusline
"   current time
set statusline=%{strftime(\"%I:%M\")}
"   FAIL or OK depending on last shell cmd
set statusline+=\ \(%{v:shell_error?\"FAIL:\":\"ok:\"}
"   exit code of last shell command
set statusline+=\ %{v:shell_error}\)
"   modified flag
set statusline+=\ %m
"   last 30 chars of file name
set statusline+=\ %-.30F
"   file type
set statusline+=\ %-y
"   left-right separator
set statusline+=%=
" character encoding
set statusline+=%{strlen(&fenc)?&fenc:&enc}
"   last operator
set statusline+=\ \[%{v:operator}\]
"   current line and column
set statusline+=\ %5.l,%-3.c
"   ASCII code of current char
set statusline+=\ \[0x%02.B\]
"   scroll position percentage
set statusline+=\ %3.p%%

" Always highlight tabs and trailing spaces.
set list
set listchars=tab:>\ ,trail:.,nbsp:.

" Always assume Unix-style line endings
set fileformats=unix

" Trailing spaces to be highlighted in red.
highlight WhitespaceEOL term=reverse ctermbg=Red guibg=Red
match WhitespaceEOL /\s\+$/

" Lines longer than 80 characters will be highlighted in red.
highlight LongLines term=reverse ctermfg=Red guifg=Red
match LongLines /^.\{81,\}$/

" Make frequent typos work.
command! Q :q
command! W :w
command! Wq :wq
command! WQ :wq
command! Wqall :wqall
command! WQall :wqall
command! WQAll :wqall

if !has('gui_running')
    " Pressing K will invoke vim_lookup_docs.sh in the PATH with the current
    " filename and the word under the cursor. That script may attempt to open
    " relevant docs according to the given arguments. Mine guesses file type
    " by it's extension and either looks up the given word in various offline
    " documentation or uses Google depending on file type.
    nnoremap K :!vim_lookup_docs.sh "%" "<cword>"<CR><CR>

    " Pressing F2 will show the complete git history of the file
    nnoremap <F2> :!clear; vim_git.sh log "%"<CR><CR>

    " Pressing F3 will search the git repository for the word under the cursor.
    nnoremap <F3> :!clear; vim_git.sh grep "%" "<cword>"<CR><CR>

    " Pressing F5 will invoke a bash shell and return to the window right after.
    nnoremap <F5> :! clear; PROMPT_EXTRA='[V]' bash<CR><CR>
endif

" Pressing F4 will attempt to git-blame the line under the cursor.
command! GitBlame :echo system('vim_git.sh blame '''.expand('%').''' '.line('.'))
nnoremap <F4> :GitBlame<CR>

" Pressing F8 will turn off search highlighting
nnoremap <F8> :nohl<CR>

" Pressing F9 will attempt to invoke unit tests through a shell script named
" vim_run_tests.sh and open the output in a new window in case of failure.
function! RunTests()
    !clear; vim_run_tests.sh /tmp/__test_output
    if shell_error!=0
        14split + /tmp/__test_output
        hi StatusLine ctermfg=darkred ctermbg=white guibg=darkred guifg=white
    else
        hi StatusLine ctermfg=darkgreen ctermbg=black guibg=darkgreen guifg=black
    endif
endfunction
nnoremap <F9> :exec RunTests() <CR><CR>

" Pressing F11 will interactively build a git commit
nnoremap <F11> :!clear ; vim_git.sh commit_selection "%"<CR><CR>

" Pressing F12 will commit everything into git
nnoremap <F12> :!clear ; vim_git.sh commit_all "%"<CR><CR>

" Highlight current line of cursor
highlight CursorLine term=underline cterm=underline
set cursorline!

" Ctrl+o will open explorer in a vertical split window
nnoremap <C-o> :Texplore<CR>

" Set default view mode for explorer to tree
let g:netrw_liststyle=3

" Make explorer hide Vim's swap files
let g:netrw_list_hide='.*\.swp$'

" Pressing 't' will jump to the next search pattern match and bring it to the
" center
nnoremap t nzz
" Pressing 'T' will jump to the last search pattern match and bring it to the
" center
nnoremap T Nzz

" Cut, copy and paste between Vim and system clipboard
vnoremap <C-c> <CR>"+y
vnoremap <C-x> <CR>"+d
inoremap <C-v> <Esc>:set paste<CR>"+p:set nopaste<CR>i

" Comment/Uncomment lines of code
autocmd BufEnter *                              let b:cmt_leader = '# '
autocmd BufEnter *                              let b:cmt_tail = ''
autocmd BufEnter *.c,*.h                        let b:cmt_leader = '/* '
autocmd BufEnter *.c,*.h                        let b:cmt_tail = ' */'
autocmd BufEnter *.hpp,*.cpp,*.java,*.php,*.js  let b:cmt_leader = '// '
autocmd BufEnter *.sh,*.ruby,*.python           let b:cmt_leader = '# '
autocmd BufEnter *.mail                         let b:cmt_leader = '> '
autocmd BufEnter *.vim                          let b:cmt_leader = '" '
noremap <silent> <C-E> :<C-B>silent <C-E>s/^\( *\)\(.*\)$/\1<C-R>=escape(b:cmt_leader,'\/')<CR>\2<C-R>=escape(b:cmt_tail,'\/')<CR>/<CR>:nohlsearch<CR>
noremap <silent> <C-U> :<C-B>silent <C-E>s/^\( *\)<C-R>=escape(b:cmt_leader,'\/*')<CR>\(.*\)<C-R>=escape(b:cmt_tail,'\/*')<CR>$/\1\2/e<CR>:nohlsearch<CR>

" Use .vim_tags as a tagfile to offer suggestions when pressing Ctrl+P.
" Requires vim_ctags.sh to be on PATH.
set tags=./.vim_tags;/
command! Ctags silent! !vim_ctags.sh ".vim_tags" "%" &
autocmd BufWritePost *.c,*.cpp,*.cc,*.h,*.hpp,*.hh,*.php* Ctags
autocmd BufWritePost *.js,*.java,*.py,*.pl,*.rb,*.cs,*.sh Ctags
Ctags

" Map usual tag shortcuts to use tabs
map <C-]> :tab split<CR>:exec("tag ".expand("<cword>"))<CR>
map <C-t> :tabprevious<CR>

" Turn on wrapping for text files.
function! ToggleWrapping()
    if empty(matchstr(expand('%'), '\.\(txt\|md\)$'))
        set textwidth=0
    else
        set textwidth=78
    endif
endfunction
autocmd BufNewFile,BufRead * exec ToggleWrapping()

" Highlight text files as Markdown
autocmd BufNewFile,BufRead *.txt,*.md set filetype=markdown

" Use tabs in Makefiles, spaces in anything else for indentation
function! ToggleTabExpansion()
    if empty(matchstr(expand('%'), '\(^\|/\)[Mm]akefile\(\.am\)\?$'))
        set expandtab
    else
        set noexpandtab
    endif
endfunction
autocmd BufNewFile,BufRead * exec ToggleTabExpansion()

" The command :Find d*f.txt will open the first file matching the given path,
" e.g. 'dir/file.txt' in a new tab.
function! Find(pattern)
    exec 'tabe ' . system('find * -path "*' . a:pattern . '*" | head -n1')
endfunction
command! -nargs=1 Find call Find('<args>')

" Press Alt+r to find a file by path and name matching
nnoremap <M-r> :Find 

" Experimenting with habit breaking
noremap <Up> <NOP>
noremap <Down> <NOP>
noremap <Left> <NOP>
noremap <Right> <NOP>
