" Turn on line numbers
set number
autocmd BufNewFile,BufRead * set number

" Turn off modelines
set nomodeline
set modelines=0

" Indent *.feature, *.xml, etc. files by 2 spaces, anything else by 4
function! SetIndentation()
    if empty(matchstr(expand('%'), '\.\(feature\|xml\|xsd\|xsl\|html\|htm\|svg\|css\|tex\)$'))
        set tabstop=4 shiftwidth=4
    else
        set tabstop=2 shiftwidth=2
    endif
endfunction
autocmd BufNewFile,BufRead * call SetIndentation()

" Scroll horizontally one character at a time
set sidescroll=1

" When wrapping is turned on, add some visual aid to continuation lines
set showbreak=\ \->\ 

" Automatic indentation
set autoindent
set smartindent

" Search while typing pattern
set incsearch

" Highlight search pattern matches
set hlsearch

" Always keep 5 lines visible on the top and the bottom when scrolling
set scrolloff=5

" Automatically format doxygen style comments
set comments=sl:/**,mb:\ *,elx:\ */

" Insert comment leader when hitting enter in Insert mode
set formatoptions+=r

" Insert comment leader when hitting o in Normal mode
set formatoptions+=o

" Font name for gVim
set guifont=Monaco\ 11

" Show current line and column numbers
set ruler

" Command line is 2 lines, so it's easier to type complex commands
set cmdheight=2

" Hide everything from GUI
set guioptions=""

" Highlight syntax
syntax on

" Some nice colorscheme
colorscheme evening
if has('gui_running')
    colorscheme koehler
endif

" Make constants readable on projector as well
highlight Constant ctermbg=black ctermfg=green

" Display the TDD state machine -- useful for screencasts
let g:tdd_state=0
let g:tdd_states=['', '   FAIL  ', '   PASS  ', ' REFACTOR']

highlight User1 ctermbg=black ctermfg=green

function! FormatTDDState()
    if g:tdd_state == 0
        return ''
    endif

    return g:tdd_states[g:tdd_state]
endfunction

function! AdvanceTDDState()
    let g:tdd_state=g:tdd_state+1

    if g:tdd_state == 4
        let g:tdd_state=1
    endif

    if g:tdd_state == 1
        highlight User1 ctermbg=black ctermfg=red
    elseif g:tdd_state == 2
        highlight User1 ctermbg=black ctermfg=green
    elseif g:tdd_state == 3
        highlight User1 ctermbg=black ctermfg=blue
    endif
endfunction

" Pressing F10 advances the TDD state to the next
noremap <F10> :call AdvanceTDDState()<CR>

" Trickery to simulate asynchronous command execution in single-threaded Vim
" using background shell execution and cursor events as result checker timer
" triggers.
" Note: A background task belongs to the buffer where it was initiated, so to
" see its results, you need to switch back to that tab/window/buffer.
let g:system_async_tasks = []
let g:system_async_orig_updatetime = &updatetime
let g:system_async_timer_set_up = 0
let g:system_async_num_running_tasks = 0

function! CallFuncByName(name, arg1, arg2, arg3, arg4)
    echo "CallFuncByName: " . a:name

    let l:Func = function(a:name)

    call Func(a:arg1, a:arg2, a:arg3, a:arg4)
endfunction

function! SystemAsync(command, stdin, ok_callback, err_callback, data)
    let l:current_file = expand("%")

    if has("win32")
        echohl None | echo "Running " . a:command . "..."

        " Windows shell is crap, fallback to synchronous execution.
        let l:output = system(a:command, a:stdin)
        let l:output = split(l:output, "\n", 1)

        if v:shell_error == 0
            call CallFuncByName(a:ok_callback, l:current_file, l:output, [""], a:data)
        else
            call CallFuncByName(a:err_callback, l:current_file, l:output, [""], a:data)
        endif

        return
    endif

    let l:tmp_file = tempname()

    let g:system_async_tasks += [[l:current_file, l:tmp_file, a:ok_callback, a:err_callback, a:data]]
    call SystemAsyncSetUpTimer()

    let l:tmp_file = shellescape(l:tmp_file)

    let l:cmd = a:command
    let l:cmd .= " >" . l:tmp_file .".out"
    let l:cmd .= " 2>" . l:tmp_file . ".err"
    let l:cmd .= " && echo >" . l:tmp_file . ".ok"
    let l:cmd .= " || echo >" . l:tmp_file . ".fail"
    let l:cmd .= " &"

    call system(l:cmd, a:stdin)
endfunction

function! SystemAsyncSetUpTimer()
    if len(g:system_async_tasks) > 0 && g:system_async_timer_set_up == 0
        let g:system_async_timer_set_up = 1
        let g:system_async_orig_updatetime = &updatetime
        set updatetime=1000
        let l:augroup_cmd = "augroup system_async"
        let l:augroup_cmd .= " | execute 'autocmd CursorHold * call SystemAsyncCheckResults()'"
        let l:augroup_cmd .= " | execute 'autocmd CursorHoldI * call SystemAsyncCheckResults()'"
        let l:augroup_cmd .= " | execute 'autocmd CursorMoved * call SystemAsyncCheckResults()'"
        let l:augroup_cmd .= " | execute 'autocmd CursorMovedI * call SystemAsyncCheckResults()'"
        let l:augroup_cmd .= " | augroup END"
        execute l:augroup_cmd
    endif
endfunction

function! SystemAsyncCheckResults()
    execute "autocmd! system_async CursorHold *"
    execute "autocmd! system_async CursorHoldI *"
    execute "autocmd! system_async CursorMoved *"
    execute "autocmd! system_async CursorMovedI *"

    let &updatetime = g:system_async_orig_updatetime
    let g:system_async_timer_set_up = 0

    let l:current_file = expand("%")

    " Iterating over task indices instead of the tasks themselves allows
    " callbacks to adjust data of any upcoming task without relying on how
    " Vimscript handles modifying lists while looping over them.

    let l:new_system_async_task_ids = []
    let l:ok_calls = []
    let l:fail_calls = []

    let l:task_id = 0
    let l:num_tasks = len(g:system_async_tasks)
    let l:num_running = 0
    let l:num_succeeded = 0
    let l:num_failed = 0

    while l:task_id < l:num_tasks
        let l:task = g:system_async_tasks[l:task_id]
        let l:succeeded = 0
        let l:failed = 0

        if filereadable(l:task[1] . ".ok")
            let l:succeeded = 1
            let l:num_succeeded += 1
        else
            if filereadable(l:task[1] . ".fail")
                let l:failed = 1
                let l:num_failed += 1
            endif
        endif

        if l:current_file == l:task[0]
            if l:succeeded != 0
                let l:ok_calls += [l:task_id]
                call delete(l:task[1] . ".ok")
            else
                if l:failed != 0
                    let l:fail_calls += [l:task_id]
                    call delete(l:task[1] . ".fail")
                else
                    let l:new_system_async_task_ids += [l:task_id]
                    let l:num_running += 1
                endif
            endif
        else
            let l:new_system_async_task_ids += [l:task_id]

            if l:succeeded == 0 && l:failed == 0
                let l:num_running += 1
            endif
        endif

        let l:task_id += 1
    endwhile

    let g:system_async_num_running_tasks = l:num_running

    echohl None | echo "Tasks: ok:" . l:num_succeeded . " failed:" . l:num_failed . " running:" . l:num_running

    for l:task_id in l:ok_calls
        let l:task = g:system_async_tasks[l:task_id]
        let l:stdout = readfile(l:task[1] . ".out")
        let l:stderr = readfile(l:task[1] . ".err")
        call delete(l:task[1] . ".out")
        call delete(l:task[1] . ".err")
        call CallFuncByName(l:task[2], l:task[0], l:stdout, l:stderr, l:task[4])
    endfor

    for l:task_id in l:fail_calls
        let l:task = g:system_async_tasks[l:task_id]
        let l:stdout = readfile(l:task[1] . ".out")
        let l:stderr = readfile(l:task[1] . ".err")
        call delete(l:task[1] . ".out")
        call delete(l:task[1] . ".err")
        call CallFuncByName(l:task[3], l:task[0], l:stdout, l:stderr, l:task[4])
    endfor

    let l:new_system_async_tasks = []

    for l:task_id in l:new_system_async_task_ids
        let l:task = g:system_async_tasks[l:task_id]
        let l:new_system_async_tasks += [l:task]
    endfor

    let g:system_async_tasks = l:new_system_async_tasks

    call SystemAsyncSetUpTimer()
endfunction

" Always show status line
set laststatus=2

" Statusline
"   current time
set statusline=%{strftime(\"%I:%M\")}
"   FAIL or OK depending on last shell cmd
set statusline+=\ \(%{v:shell_error?\"FAIL:\":\"ok:\"}
"   exit code of last shell command
set statusline+=\%{v:shell_error}\)
"   modified flag
set statusline+=\%m
"   last 22 chars of file name
set statusline+=\ \%-.22F
"   file type
set statusline+=%-y
"   left-right separator
set statusline+=%=
" character encoding
set statusline+=%{strlen(&fenc)?&fenc:&enc}
"   last operator
set statusline+=\ \[%{v:operator}\]
"   current line and column
set statusline+=\ %5.l,%-3.c
"   ASCII code of current char
set statusline+=x%02.B
"   scroll position percentage
set statusline+=\ %3.p%%
"   background tasks
set statusline+=\ B:%{g:system_async_num_running_tasks}
" TDD state
set statusline+=%1*%{FormatTDDState()}

" Always highlight tabs and trailing spaces.
set list
set listchars=tab:>\ ,trail:.,nbsp:.

" Always assume Unix-style line endings
set fileformats=unix

" Trailing spaces to be highlighted in red.
highlight WhitespaceEOL term=reverse ctermbg=Red guibg=Red
match WhitespaceEOL /\s\+$/

" Make frequent typos work.
command! Q :q
command! Qall :qall
command! QAll :qall
command! W :w
command! Wq :wq
command! WQ :wq
command! Wqall :wqall
command! WQall :wqall
command! WQAll :wqall

if !has('gui_running')
    " Pressing K will invoke vim_lookup_docs.sh in the PATH with the current
    " filename and the word under the cursor. That script may attempt to open
    " relevant docs according to the given arguments. Mine guesses file type
    " by it's extension and either looks up the given word in various offline
    " documentation or uses Google depending on file type.
    nnoremap K :!vim_lookup_docs.sh "%" "<cword>"<CR><CR>

    " Pressing F2 will show the complete git history of the file
    nnoremap <F2> :!clear; vim_git.sh log "%"<CR><CR>

    " Pressing F3 will search the git repository for the word under the cursor.
    nnoremap <F3> :!clear; vim_git.sh grep "%" "<cword>"<CR><CR>

    " Pressing F5 will invoke a bash shell and return to the window right after.
    nnoremap <F5> :! clear; PROMPT_EXTRA='[V]' bash<CR><CR>
endif

" Pressing F4 will attempt to git-blame the line under the cursor.
command! GitBlame :echo system('vim_git.sh blame ' . shellescape(expand('%')) . ' ' . line('.'))
nnoremap <F4> :GitBlame<CR>

function! OpenAll(command, pattern_to_position_cursor)
    for l:f in split(system(a:command .  ' 2>/dev/null | grep -Ev ''[.](swp|pyc|pickle)$'''), "\n")
        execute "tabedit " . l:f
        if a:pattern_to_position_cursor!=''
            execute '/' . a:pattern_to_position_cursor
            nohl
        endif
    endfor
endfunction

" The command :Grep pattern will open all the files matching pattern
" in a case sensitive manner
function! Grep(pattern)
    call OpenAll('grep -Rlm1 -- ' . shellescape(a:pattern) . ' *', a:pattern)
endfunction
command! -nargs=1 Grep call Grep('<args>')
command! -nargs=1 G call Grep('<args>')
command! -nargs=0 GrepCurrentWord call Grep(expand('<cword>'))
command! -nargs=0 GCW call Grep(expand('<cword>'))

" Press F6 to open all files containing the word under the cursor
nnoremap <F6> :call Grep(expand('<cword>'))<CR>

" The command :GitGrep pattern will open all the files in a git repository
" matching pattern in a case sensitive manner
function! GitGrep(pattern)
    call OpenAll('git grep -l -- ' . shellescape(a:pattern) . ' *', a:pattern)
endfunction
command! -nargs=1 GitGrep call GitGrep('<args>')
command! -nargs=1 GG call GitGrep('<args>')
command! -nargs=0 GitGrepCurrentWord call GitGrep(expand('<cword>'))
command! -nargs=0 GGCW call GitGrep(expand('<cword>'))

" The command :Find d*f.txt will open all the files matching the given path,
" in a case insensitive manner, e.g. 'dir/File.txt', in a new tab.
function! Find(pattern)
    call OpenAll('find -L * -ipath ' . shellescape('*' . a:pattern), '')
endfunction
command! -nargs=1 Find call Find('<args>')
command! -nargs=1 F call Find('<args>')
command! -nargs=0 FindCurrentWord call Find(expand('<cword>'))
command! -nargs=0 FCW call Find(expand('<cword>'))

" Press F7 to find a file by path and name matching
nnoremap <F7> :Find 

" The command :FindClass Name will open all the files matching 'class Name'
" or 'interface Name' in a case insensitive manner
function! FindClass(pattern)
    let l:pattern = '\(^\|[^a-zA-Z0-9_]\)\(\(class\)\|\(interface\)\)\s\s*' . a:pattern . '\([^a-zA-Z0-9_]\|$\)'
    call OpenAll('grep -Rilm1 ' . shellescape(l:pattern) . ' *', l:pattern)
endfunction
command! -nargs=1 FindClass call FindClass('<args>')
command! -nargs=1 FC call FindClass('<args>')
command! -nargs=0 FindClassCurrentWord call FindClass(expand('<cword>'))
command! -nargs=0 FCCW call FindClass(expand('<cword>'))

" The command :GitFindClass Name will open all the files matching 'class Name'
" or 'interface Name' in a git repository in a case insensitive manner
function! GitFindClass(pattern)
    let l:pattern = '\(^\|[^a-zA-Z0-9_]\)\(\(class\)\|\(interface\)\)\s\s*' . a:pattern . '\([^a-zA-Z0-9_]\|$\)'
    call OpenAll('git grep -il ' . shellescape(l:pattern) . ' *', l:pattern)
endfunction
command! -nargs=1 GitFindClass call GitFindClass('<args>')
command! -nargs=1 GFC call GitFindClass('<args>')
command! -nargs=0 GitFindClassCurrentWord call GitFindClass(expand('<cword>'))
command! -nargs=0 GFCCW call GitFindClass(expand('<cword>'))

" Pressing F8 will turn off search highlighting and reset syntax highlighting
nnoremap <F8> :nohl<CR>:syntax sync fromstart<CR>

" Pressing F9 will attempt to invoke unit tests through a shell script named
" vim_run_tests.sh and open the output in a new window in case of failure.
function! RunTests()
    !clear; vim_run_tests.sh '%' /tmp/__test_output
    if shell_error!=0
        14split + /tmp/__test_output
        hi StatusLine ctermfg=darkred ctermbg=white guibg=darkred guifg=white
    else
        hi StatusLine ctermfg=darkgreen ctermbg=black guibg=darkgreen guifg=black
    endif
endfunction
nnoremap <F9> <Esc> :call RunTests() <CR><CR>

" Pressing F11 will interactively build a git commit
nnoremap <F11> :!clear ; vim_git.sh commit_selection "%"<CR><CR>

" Pressing F12 will commit everything into git
nnoremap <F12> :!clear ; vim_git.sh commit_all "%"<CR><CR>

" Highlight current line of cursor
highlight CursorLine term=underline cterm=underline
set cursorline!

" Ctrl+o will open explorer in a new tab
nnoremap <C-o> :Texplore<CR>

" Set default view mode for explorer to tree
let g:netrw_liststyle=3

" Make explorer hide Vim's swap files
let g:netrw_list_hide='.*\.swp$'

" Pressing 't' will jump to the next search pattern match and bring it to the
" center
nnoremap t nzz
" Pressing 'T' will jump to the last search pattern match and bring it to the
" center
nnoremap T Nzz

" Cut, copy and paste between Vim and system clipboard
vnoremap <C-c> <CR>"+y
vnoremap <C-x> <CR>"+d
inoremap <C-v> <Esc>:set paste<CR>"+p:set nopaste<CR>i

" Comment/Uncomment lines of code when pressing Ctrl+E or Ctrl+U
autocmd BufEnter *                              let b:cmt_leader = '# '
autocmd BufEnter *                              let b:cmt_tail = ''
autocmd BufEnter *.c,*.h                        let b:cmt_leader = '/* '
autocmd BufEnter *.c,*.h                        let b:cmt_tail = ' */'
autocmd BufEnter *.cpp,*.hpp                    let b:cmt_leader = '// '
autocmd BufEnter *.css                          let b:cmt_leader = '/* '
autocmd BufEnter *.css                          let b:cmt_tail = ' */'
autocmd BufEnter *.htm,*.html                   let b:cmt_leader = '<!-- '
autocmd BufEnter *.htm,*.html                   let b:cmt_tail = ' -->'
autocmd BufEnter *.java                         let b:cmt_leader = '// '
autocmd BufEnter *.jsfx                         let b:cmt_leader = '// '
autocmd BufEnter *.js                           let b:cmt_leader = '// '
autocmd BufEnter *.mail                         let b:cmt_leader = '> '
autocmd BufEnter *.php                          let b:cmt_leader = '// '
autocmd BufEnter *.py,*.python                  let b:cmt_leader = '# '
autocmd BufEnter *.ruby                         let b:cmt_leader = '# '
autocmd BufEnter *.sh                           let b:cmt_leader = '# '
autocmd BufEnter *.svg                          let b:cmt_leader = '<!-- '
autocmd BufEnter *.svg                          let b:cmt_tail = ' -->'
autocmd BufEnter *.tex                          let b:cmt_leader = '% '
autocmd BufEnter *.tpl                          let b:cmt_leader = '<!-- '
autocmd BufEnter *.tpl                          let b:cmt_tail = ' -->'
autocmd BufEnter *.vim,.vimrc,vimrc             let b:cmt_leader = '" '
autocmd BufEnter *.xml                          let b:cmt_leader = '<!-- '
autocmd BufEnter *.xml                          let b:cmt_tail = ' -->'
noremap <silent> <C-E> :<C-B>silent <C-E>s/^\( *\)\([^ ].*\)$/\1<C-R>=escape(b:cmt_leader,'\/')<CR>\2<C-R>=escape(b:cmt_tail,'\/')<CR>/<CR>:nohlsearch<CR>
noremap <silent> <C-U> :<C-B>silent <C-E>s/^\( *\)<C-R>=escape(b:cmt_leader,'\/*')<CR>\(.*\)<C-R>=escape(b:cmt_tail,'\/*')<CR>$/\1\2/e<CR>:nohlsearch<CR>

" Use .vim_tags as a tagfile to offer suggestions when pressing Ctrl+P.
" Requires vim_ctags.sh to be on PATH.
set tags=./.vim_tags;/
command! Ctags silent! !vim_ctags.sh ".vim_tags" "%" &
autocmd BufWritePost *.c,*.cpp,*.cc,*.h,*.hpp,*.hh,*.php* Ctags
autocmd BufWritePost *.js,*.java,*.py,*.pl,*.rb,*.cs,*.sh Ctags
Ctags

" Map usual tag shortcuts to use tabs
map <C-]> :tab split<CR>:exec("tag ".expand("<cword>"))<CR>
map <C-t> :tabprevious<CR>

" Turn on auto-wrapping for text files and display a margin
function! ToggleWrapping()
    if 0 != len(matchstr(expand('%'), '\(COMMIT_\)\|\(mail\.\)\|\(\.mail\)\|\(\.rst\)'))
        set textwidth=72
        set colorcolumn=73
    elseif 0 != len(matchstr(expand('%'), '\.\(txt\|md\)$'))
        set textwidth=79
        set colorcolumn=80
        " turn off automatic comment leaders
        set formatoptions=tq
    else
        set textwidth=0
        set colorcolumn=81
    endif
endfunction
autocmd BufNewFile,BufRead * call ToggleWrapping()

" Additional rules to turn on syntax highlighting for various file types
autocmd BufNewFile,BufRead *.jsfx           set filetype=javascript
autocmd BufNewFile,BufRead *.md             set filetype=markdown
autocmd BufNewFile,BufRead *.rst            set filetype=rst
autocmd BufNewFile,BufRead *.tpl            set filetype=htmldjango
autocmd BufNewFile,BufRead *.twig           set filetype=htmldjango

" Use tabs in Makefiles, go files, TSV files, etc. and spaces in anything
" else for indentation
function! ToggleTabExpansion()
    let l:pattern = '\(^\|/\)\(\([Mm]akefile\(\..*\)\?\)\|\(debian/rules\)\|\(.*\.go\)\|\(.*\.tsv\)\)$'
    if empty(matchstr(expand('%'), l:pattern))
        set expandtab
    else
        set noexpandtab
    endif
endfunction
autocmd BufNewFile,BufRead * call ToggleTabExpansion()

" Attempt to locate the step definition for the .feature step under the
" cursor inside a git repository.
function! GitFindStep()
    if empty(matchstr(expand('%'), '[.]feature$'))
        return
    endif

    let l:blacklist = ["first [^ ]*", "second [^ ]*", "third [^ ]*", "fourth [^ ]*", "fifth [^ ]*", "seventh [^ ]*", "eighth [^ ]*", "ninth [^ ]*", "last [^ ]*"]
    let l:line = getline('.')
    let l:pattern_wo_nonalpha = substitute(l:line, "[^a-zA-Z_ \"-]\\+", "[^ ]*", "g")
    let l:pattern_w_prefix = substitute(l:pattern_wo_nonalpha, "^ *[A-Za-z]* ", "^[^a-zA-Z0-9_-]*@[a-zA-Z]*[^a-zA-Z]*", "")
    let l:pattern_wo_short_words = substitute(l:pattern_w_prefix, "\\([^a-zA-Z_-]\\)[a-zA-Z_-]\\{1,3\\}\\( \\|$\\)", "\\1[^ ]*\\2", "g")
    let l:pattern_wo_params = substitute(l:pattern_wo_short_words, "\"[^\"]*\"", ".*", "g")
    let l:pattern_wo_blacklisted_words = substitute(l:pattern_wo_params, "\\(" . join(l:blacklist, "\\)\\|\\(") . "\\)", "[^ ]* [^ ]*", "g")
    call GitGrep(l:pattern_wo_blacklisted_words)
endfunction

" Pressing Ctrl+i attempts to find the step definition to the .feature
" step under the cursor inside a git repository.
noremap <C-i> :call GitFindStep()<CR>

" :w!! will save the file as root
cmap w!! w !sudo tee % >/dev/null

" Trailing commas to be highlighted in Python, in order to avoid
" typo tuples:
"
"     def foo(x):
"         return x + 1,
function! HighlightTrailingComma()
    highlight TrailingComma term=reverse ctermbg=Blue guibg=Blue
    match TrailingComma /,\+$/
endfunction
autocmd BufEnter *.py call HighlightTrailingComma()

" All dots to be highlighted in JavaScript, in order to avoid typos like
" this:
"
"     (function () {
"
"         'use strict';
"
"         function foo(a, b)
"         {
"             console.log([a ? 1 : 0, b ? 1 : 0]);
"         }
"
"         foo(true, true);      // Array [ 1, 1 ]
"         foo(false, false);    // Array [ 0, 0 ]
"         foo(true. false);     // Array [ 0, 0 ]
"         foo(false. true);     // Array [ 0, 0 ]
"
"    })();
function! HighlightAllDots()
    highlight AllDots term=reverse ctermbg=Blue guibg=Blue
    match AllDots /\.\+/
endfunction
autocmd BufEnter *.js call HighlightAllDots()

function! AICatCmd(args)
    let l:console_file = "/dev/tty"

    if has("win32")
        " The redirection to the special console file doesn't work in gVim,
        " so there will be no streaming. At least, it works in a terminal based
        " vim.exe.
        let l:console_file = "CON"
    endif

    " The command will replace the buffer with the stdout while displaying its
    " stderr in the terminal.
    return "ai-cat.py " . a:args . " 2>" . l:console_file
endfunction

" The :AI command will run the current buffer through ai-cat.py (must be on
" PATH) in order to generate a continuation if it looks like an already
" established ai-cat.py conversation, otherwise it will initialize a new
" conversation in a new tab.
function! AICat()
    let l:ai_cat_cmd = "%!" . AICatCmd("stdio")
    let l:cursor_position = getpos(".")

    " Does the currently edited buffer's name look like an ai-cat.py
    " conversation? If the name is empty or ends with .md, then it does.
    let l:may_be_ai_conversation = (expand("%") =~ "^\\(.*\\.md\\)\\?$")

    " Is the buffer an already initialized, ongoing ai-act.py conversation?
    " If it contains block header lines used by ai-act.py, then it is.
    let l:is_ai_conversation = 0

    if l:may_be_ai_conversation
        for l:line_num in range(1, line("$"))
            if getline(l:line_num) =~ "^# === .* ===\\r\\?$"
                let l:is_ai_conversation = 1
                break
            endif
        endfor
    endif

    if l:is_ai_conversation
        " Run the conversation through ai-cat, and put the cursor at the
        " beginning of the last AI, AI Reasoning, or User block or to the end
        " if none of them can be found.

        echohl None | echo "Waiting for AI..."

        execute l:ai_cat_cmd

        if v:shell_error != 0
            undo
            call setpos(".", l:cursor_position)
            return
        endif

        redraw!

        call AIJumpToRelevantBlock()
    else
        " Need to initialize a new conversaion - since this will overwrite the
        " entire buffer, we do it in a new tab if the current one is not empty
        " or its name doesn't look like an ai-cat.py conversaion.

        if line("$") != 1 || getline(1) != "" || !l:may_be_ai_conversation
            tabnew
        endif

        echohl None | echo "Initializing conversation..."

        execute l:ai_cat_cmd
        set filetype=markdown

        if v:shell_error != 0
            undo
            return
        endif

        redraw!
        normal! G
        startinsert
    endif
endfunction
command! -nargs=0 AI call AICat()

function! AIJumpToRelevantBlock()
    let l:response_pos = 0

    for l:line_num in range(line("$"), 1, -1)
        if getline(l:line_num) =~ "^# === \\(AI\\( Reasoning\\)*\\|User\\) ===\\r\\?$"
            let l:response_pos = l:line_num
            break
        endif
    endfor

    if l:response_pos > 0
        call cursor(l:response_pos, 1)
    else
        normal! G
    endif
endfunction

" Add to-do comments to a piece of code, select the relevant lines, then press
" the Tab key to run them through the last used AI in ai-cat.py. If the AI
" requests more information or otherwise fails to produce a usable replacement,
" then the conversation is opened in a new tab for editing. From there, the
" `:AI` command can be used for continuing it. (See above.)
"
" NOTE: only the selected lines and the name of the edited file are sent to the
"       AI, so make sure that they contain all the necessary information.
function! AICatTabReplace() range
    let l:begin_line = line("'<")
    let l:end_line = line("'>")

    if l:begin_line == 0 || l:end_line == 0
        echohl ErrorMsg | echo "Select the lines first to be replaced by AI." | echohl None
        return
    endif

    let l:ai_cat_cmd = AICatCmd("replace " . shellescape(expand("%")))
    let l:input = join(getline(l:begin_line, l:end_line), "\n") . "\n"
    let l:data = [l:begin_line, l:end_line, l:input]

    echohl None | echo "Sending request to AI..."

    call SystemAsync(l:ai_cat_cmd, l:input, "AICatTabReplaceCbOk", "AICatTabReplaceCbErr", l:data)
endfunction
xnoremap <silent> <Tab> :call AICatTabReplace()<CR>

function! AICatTabReplaceCbOk(file_name, stdout, stderr, data)
    let l:begin_line = a:data[0]
    let l:end_line = a:data[1]
    let l:old_lines = a:data[2]

    let l:current_lines = join(getline(l:begin_line, l:end_line), "\n") . "\n"

    if l:old_lines != l:current_lines
        redraw!
        tabnew
        call append(0, a:stdout)
        echo "Conflicting changes in buffer while the AI was working"
        return
    endif

    let l:current_pos = getpos(".")
    let l:current_line = l:current_pos[1]
    let l:current_col = l:current_pos[2]

    execute l:begin_line . "," . l:end_line . "delete _"
    call append(l:begin_line - 1, a:stdout)

    let l:line_num_delta = len(a:stdout) - (l:end_line - l:begin_line + 1)
    let l:current_line += l:line_num_delta

    let l:task_id = 0
    let l:num_tasks = len(g:system_async_tasks)

    execute "normal! " . l:current_line . "G" . l:current_col . "|"
    redraw!

    while l:task_id < l:num_tasks
        let l:task = g:system_async_tasks[l:task_id]

        if l:task[0] == a:file_name && l:task[2] == "AICatTabReplaceCbOk"
            let l:task_data = l:task[4]

            if l:task_data[1] > l:end_line
                let g:system_async_tasks[l:task_id][4][0] += l:line_num_delta
                let g:system_async_tasks[l:task_id][4][1] += l:line_num_delta
            endif
        endif

        let l:task_id += 1
    endwhile
endfunction

function! AICatTabReplaceCbErr(file_name, stdout, stderr, data)
    redraw!
    tabnew
    set filetype=markdown
    call append(0, a:stderr)
    call append(0, a:stdout)
    call AIJumpToRelevantBlock()
    echo "Failed to get suitable replacemenet, use :AI to continue the conversation after editing"
    return
endfunction

" Pressing I (Shift+i) in Visual mode will select everything between the
" previous and the next Markdown code fence. (Does not handle code blocks
" that are nested inside other elements like list items or block quotes.)
function! SelectBetweenMarkdownFences()
    let l:current_line = line(".")
    let l:begin = 1
    let l:end = line("$")

    " Could use search("^```", "Wbcn") and search("^```", "Wn"), but that would
    " mess up the search history.

    for l:line_num in range(l:current_line, 1, -1)
        if getline(l:line_num) =~ "^```"
            let l:begin = l:line_num + 1
            break
        endif
    endfor

    for l:line_num in range(l:current_line + 1, line("$"))
        if getline(l:line_num) =~ "^```"
            let l:end = l:line_num - 1
            break
        endif
    endfor

    if l:begin > l:end
        return
    endif

    execute "normal! " . l:begin . "Gv" . l:end . "G$"
endfunction
xnoremap <silent> I :call SelectBetweenMarkdownFences()<CR>
